module analysis/types/stack-constraints

imports
  include/JasminXT
  analysis/names/properties
  analysis/names/extra-constructors
  runtime/nabl/-
  runtime/task/-
  runtime/types/-

rules
  fresh-var = !TypeVar(<new>)

  stack-constraints(|ctx): JBCMethod(_, _, _, []) -> []
  stack-constraints(|ctx): JBCMethod(_, _, _, l@[h|_]) -> [CEq(h-in, []), push, pop, complex*, next*]
    where h-in  := <get-in-stack>  h
        ; h-out := <get-out-stack> h
        ; push  := <map(push-constraints)> l
        ; pop   := <map(pop-constraints)> l
        ; next* := <foldl(next-constraints(|ctx));Snd> (l, (h-out, []))
        ; complex* := []
  
  pop-constraints: instr -> CSub(i-in, [p*, <fresh-var>])
    where p* := <pop-type> instr
        ; i-in := <get-in-stack> instr
  pop-type = get-pop-type;try(?[s];<is-string> s;<print-failure(|s)> "") <+ []

  push-constraints: instr -> CSub(i-in, [p*, <fresh-var>])
    where p* := <push-type> instr
        ; i-in := <get-in-stack> instr
  push-type = get-push-type;try(?[s];<is-string> s;<print-failure(|s)> "")

  next-constraints(|ctx): (instr, (prev-out, c*)) -> (<get-out-stack> instr, [n*, c*])
    where i-in := <get-in-stack> instr
        ; n* := <next-instr;map(next-helper(|ctx, prev-out, i-in))> instr
  
  next-helper(|ctx,prev-out,i-in) = \NEXT() -> CEq(prev-out,i-in)\
                                 <+ \LabelRef(l) -> CEq(prev-out,<nabl-lookup-all(|ctx);Hd;get-in-stack> l)\
  next-instr = get-next-instr <+ ![NEXT()]
  
  complex-constraints(|instr, tv) = id