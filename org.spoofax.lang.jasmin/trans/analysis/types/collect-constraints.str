module analysis/types/collect-constraints

imports
  include/JasminXT
  analysis/names/properties
  analysis/names/extra-constructors
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  trans/match-Instruction

rules
  fresh-var = !TypeVar(<new>)

  stack-constraints(|ctx, classname): JBCMethod(_, _, JBCMethodDesc(_,r), []) -> ([], [CEq(r, Void())])
  stack-constraints(|ctx, classname): JBCMethod(_, _, JBCMethodDesc(p,r), l) -> ([st-start, push*, pop*, next*, st-c*], [reg-start, next*, reg-c*])
    where l'@[h|_] := <filter(match-Instruction)> l
    	; h-in  := <get-in-stack>  h
        ; h-out := <get-out-stack> h
        ; next* := <foldl(next-constraints(|ctx));Snd> (l', (h-out, []))
          // TODO: add more constraints for local variables
        ; (st-c*,reg-c*) := <foldl(complex-constraints(|r))> (l', ([],[]))
          
    	; st-start := CEq(TypeVar(h-in), [])
        ; push* := <filter(push-constraints)> l'
        ; pop*  := <filter(pop-constraints)> l'
          
        ; locals-start := ([ Reference(CRef(classname)) | p ], <fresh-var>)
        ; reg-start := CEq(TypeVar(h-in), locals-start)
        // TODO: handle limits in constraints. 
          // limit locals can be done with a single constraint wherever it is found, setting the locals CSub of [TOP(), ..., TOP()] of the size given in the limit locals phrase
          // limit stack may need intelligent constaints on every in/out stack.. Not sure yet how to solve this
  
  pop-constraints: instr -> CEq(TypeVar(i-in), (p*, <fresh-var>))
    where p* := <pop-type> instr
        ; i-in := <get-in-stack> instr
  pop-type = get-pop-type;not(?[])

  push-constraints: instr -> CEq(TypeVar(i-out), (p*, <fresh-var>))
    where p* := <push-type> instr
        ; i-out := <get-out-stack> instr
  push-type = get-push-type;not(?[])

  next-constraints(|ctx): (instr, (prev-out, c*)) -> (<get-out-stack> instr, [n*, c*])
    where i-in := <get-in-stack> instr
        ; n* := <next-instr;map(next-helper(|ctx, prev-out, i-in))> instr
  
  next-helper(|ctx,prev-out,i-in) = \NEXT() -> CEq(TypeVar(prev-out),TypeVar(i-in))\
                                 <+ \LabelRef(l) -> CEq(TypeVar(prev-out),<get-in-stack> l)\
  next-instr = get-next-instr <+ ![NEXT()]
  
  complex-constraints(|r) = complex-constraint(|r) <+ ?(_, <id>)
    
  complex-constraint(|r): (instr@ATHROW(), (c*,r*)) -> ([n*, c*], [r*])
    where cref  := Reference(CRef(<fresh-var>))
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), ([cref], <fresh-var>)) // pop-type
    	        , CEq(TypeVar(i-out), [cref])               // push-type
    	        ]
  complex-constraint(|r): (instr@CHECKCAST(_), (c*,r*)) -> ([n*, c*], [r*])
    where cref  := Reference(CRef(<fresh-var>))
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), ([cref], <fresh-var>)) // pop-type
    	        , CEq(TypeVar(i-out), TypeVar(i-in))        // push-type
    	        ]
  complex-constraint(|r): (instr@DUP(), (c*,r*)) -> ([n*, c*], [r*])
    where type@TypeVar(type') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in),  ([type], rest))       // pop-type
    	        , CEq(TypeVar(i-out), ([type, type], rest)) // push-type
    	        , CNEq(TypeVar(type'), Double())
    	        , CNEq(TypeVar(type'), Long())
    	        ]
  complex-constraint(|r): (instr@DUP2(), (c*,r*)) -> ([n*, c*], [r*])
    where type@TypeVar(type')  := <fresh-var>
        ; type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type], rest))       // pop-type
    	                , CEq(TypeVar(i-out), ([type, type], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type'), Double()) ]
    	                      , [ CEq(TypeVar(type'), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                ]
    	              ])
    	        ]
  complex-constraint(|r): (instr@DUP_X1(), (c*,r*)) -> ([n*, c*], [r*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	        , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	        , CNEq(TypeVar(type1'), Double())
    	        , CNEq(TypeVar(type1'), Long())
    	        , CNEq(TypeVar(type2'), Double())
    	        , CNEq(TypeVar(type2'), Long())
    	        ]
  complex-constraint(|r): (instr@DUP2_X1(), (c*,r*)) -> ([n*, c*], [r*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(type2'), Double())
              	, CEq(TypeVar(type2'), Long())
              	, COr([ [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type1), Double()) ]
    	                      , [ CEq(TypeVar(type1), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type3'), Double())
              	        , CNEq(TypeVar(type3'), Long())
    	                ]
    	              ])
    	        ]
  complex-constraint(|r): (instr@DUP_X2(), (c*,r*)) -> ([n*, c*], [r*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(type1'), Double())
                , CEq(TypeVar(type1'), Long())
                , COr( [ [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))        // pop-type
    	                 , CEq(TypeVar(i-out), ([type1, type2, type3, type1], rest)) // push-type
    	                 , CNEq(TypeVar(type2'), Double())
    	                 , CNEq(TypeVar(type2'), Long())
    	                 , CNEq(TypeVar(type3'), Double())
    	                 , CNEq(TypeVar(type3'), Long())
    	                 ]
    	               , [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	                 , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	                 , COr([ [ CEq(TypeVar(type2'), Double()) ]
    	                       , [ CEq(TypeVar(type2'), Long())   ]
    	                       ])
    	                 ]
    	               ])
	            ]
  complex-constraint(|r): (instr@DUP2_X2(), (c*,r*)) -> ([n*, c*], [r*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; type4@TypeVar(type4') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))        // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type1], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type1'), Double()) ]
    	                      , [ CEq(TypeVar(type1'), Long()) ]
    	                      ])
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                , CNEq(TypeVar(type3'), Double())
              	        , CNEq(TypeVar(type3'), Long())
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type1'), Double()) ]
    	                      , [ CEq(TypeVar(type1'), Long()) ]
    	                      ])
    	                , COr([ [ CEq(TypeVar(type2'), Double()) ]
    	                      , [ CEq(TypeVar(type2'), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                , COr([ [ CEq(TypeVar(type3'), Double()) ]
    	                      , [ CEq(TypeVar(type3'), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2, type3, type4], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type4, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                , CNEq(TypeVar(type3'), Double())
              	        , CNEq(TypeVar(type3'), Long())
    	                , CNEq(TypeVar(type4'), Double())
              	        , CNEq(TypeVar(type4'), Long())
    	                ]
    	              ])
    	        ]
  complex-constraint(|r): (instr@SWAP(), (c*,r*)) -> ([n*, c*], [r*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in),  ([type1, type2], rest)) // pop-type
    	        , CEq(TypeVar(i-out), ([type2, type1], rest)) // push-type
    	        , CNEq(TypeVar(type1'), Double())
    	        , CNEq(TypeVar(type1'), Long())
    	        , CNEq(TypeVar(type2'), Double())
    	        , CNEq(TypeVar(type2'), Long())
    	        ]
  complex-constraint(|r): (instr@RETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Void()) ]
  complex-constraint(|r): (instr@IRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Int()) ]
  complex-constraint(|r): (instr@LRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Long()) ]
  complex-constraint(|r): (instr@FRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Float()) ]
  complex-constraint(|r): (instr@DRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Double()) ]
  complex-constraint(|r): (instr@ARETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; classtype := Reference(CRef(<fresh-var>))
    	; n* := [ CEq(TypeVar(i-out), [])         // push-type
    	        , CEq(TypeVar(i-in), [classtype]) // pop-type
    	        , CSub(classtype, r) ]
      	        
  complex-constraint(|r): (instr@MONITORENTER(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), [Reference(CRef(<fresh-var>))]) ] // pop-type
  complex-constraint(|r): (instr@MONITOREXIT(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), [Reference(CRef(<fresh-var>))]) ] // pop-type
    	  
  complex-constraint(|r): (instr@BALOAD(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ COr([ [CEq(TypeVar(i-out), ([Byte()],<fresh-var>))]
    	              , [CEq(TypeVar(i-out), ([Boolean()],<fresh-var>))]]) ] // push-type
  complex-constraint(|r): (instr@BASTORE(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
    	; n* := [ COr([ [CEq(TypeVar(i-in), ([Byte()],<fresh-var>))]
    	              , [CEq(TypeVar(i-in), ([Boolean()],<fresh-var>))]]) ] // pop-type
  complex-constraint(|r): (instr@AALOAD(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef(<fresh-var>))
        ; array-type := Array(<fresh-var>)
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([Int(), Array(class-type)], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([class-type],rest))               ] // push-type
    	             , [ CEq(TypeVar(i-in), ([Int(), Array(array-type)], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([array-type],rest))               ] // push-type
    	             ])]
  complex-constraint(|r): (instr@AASTORE(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef(<fresh-var>))
        ; array-type := Array(<fresh-var>)
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([class-type, Int(), Array(class-type)], rest)) ] // pop-type
    	             , [ CEq(TypeVar(i-in), ([array-type, Int(), Array(array-type)], rest)) ] // pop-type
    	             ])]
  complex-constraint(|r): (instr@BALOAD(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([Int(), Array(Boolean())], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([Boolean()],rest))               ] // push-type
    	             , [ CEq(TypeVar(i-in), ([Int(), Array(Byte())], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([Byte()],rest))               ] // push-type
    	             ])]
  complex-constraint(|r): (instr@BASTORE(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([Boolean(), Int(), Array(Boolean())], rest)) ] // pop-type
    	             , [ CEq(TypeVar(i-in), ([Byte(), Int(), Array(Byte())], rest)) ]       // pop-type
    	             ])]
    	             
  cc-aload-helper(|type): (instr, c*) -> [n*, c*]
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in), ([Int(), Array(type)], rest))   // pop-type
                , CEq(TypeVar(i-out), ([type],rest))               ] // push-type
  cc-astore-helper(|type): (instr, c*) -> [n*, c*]
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in), ([type, Int(), Array(type)], rest)) ] // pop-type
  complex-constraint(|r): (CALOAD(),  (_, _)) -> <cc-aload-helper(|Char())>
  complex-constraint(|r): (CASTORE(), (_, _)) -> <cc-astore-helper(|Char())>
  complex-constraint(|r): (DALOAD(),  (_, _)) -> <cc-aload-helper(|Double())>
  complex-constraint(|r): (DASTORE(), (_, _)) -> <cc-astore-helper(|Double())>
  complex-constraint(|r): (FALOAD(),  (_, _)) -> <cc-aload-helper(|Float())>
  complex-constraint(|r): (FASTORE(), (_, _)) -> <cc-astore-helper(|Float())>
  complex-constraint(|r): (IALOAD(),  (_, _)) -> <cc-aload-helper(|Int())>
  complex-constraint(|r): (IASTORE(), (_, _)) -> <cc-astore-helper(|Int())>
  complex-constraint(|r): (LALOAD(),  (_, _)) -> <cc-aload-helper(|Long())>
  complex-constraint(|r): (LASTORE(), (_, _)) -> <cc-astore-helper(|Long())>
  complex-constraint(|r): (SALOAD(),  (_, _)) -> <cc-aload-helper(|Short())>
  complex-constraint(|r): (SASTORE(), (_, _)) -> <cc-astore-helper(|Short())>
    	  
  complex-constraint(|r): (instr@name#([_]), (c*,r*)) -> ([n*, c*], [r*])
    where <string-starts-with(|"ASTORE")> name
    	; i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef(<fresh-var>))
    	; n* := [ CEq(TypeVar(i-in), ([class-type], rest)) ] // pop-type

  complex-constraint(|r): (instr@name#([JBCMethodRef(cref, _, JBCMethodDesc(p, r))]), (c*,r*)) -> ([n*, c*], [r*])
    where (!"INVOKESPECIAL" => name + !"INVOKEVIRTUAL" => name + !"INVOKEINTERFACE" => name)
    	; i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack> instr
        ; rest  := <fresh-var>
        ; class-type := Reference(cref)
        ; ret-type := <try(\[Void()] -> []\)> [r]
        ; n* := [ CSub(i-in, (<reverse> [class-type|p], rest))   // pop-type
                , CSub(i-out, (ret-type, rest))                ] // push-type
  complex-constraint(|r): (instr@INVOKESTATIC(JBCMethodRef(_, _, JBCMethodDesc(p, r))), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack> instr
        ; rest  := <fresh-var>
        ; ret-type := <try(\[Void()] -> []\)> [r]
        ; n* := [ CSub(i-in, (<reverse> p, rest))   // pop-type
                , CSub(i-out, (ret-type, rest))   ] // push-type
