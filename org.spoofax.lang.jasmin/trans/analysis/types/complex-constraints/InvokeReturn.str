module analysis/types/complex-constraints/InvokeReturn

imports
  include/JasminXT
  analysis/names/properties
  analysis/types/constraints

rules
  complex-constraint(|r): (instr@name#([JBCMethodRef(cref, _, JBCMethodDesc(p, r))]), (c*,r*)) -> ([n*, c*], [r*])
    where (!"INVOKESPECIAL" => name + !"INVOKEVIRTUAL" => name + !"INVOKEINTERFACE" => name)
    	; i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack> instr
        ; rest  := <fresh-var>
        ; class-type := Reference(cref)
        ; ret-type := <try(\[Void()] -> []\)> [r]
        ; n* := [ CSub(i-in, (<reverse> [class-type|p], rest))   // pop-type
                , CSub(i-out, (ret-type, rest))                ] // push-type
  complex-constraint(|r): (instr@INVOKESTATIC(JBCMethodRef(_, _, JBCMethodDesc(p, r))), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack> instr
        ; rest  := <fresh-var>
        ; ret-type := <try(\[Void()] -> []\)> [r]
        ; n* := [ CSub(i-in, (<reverse> p, rest))   // pop-type
                , CSub(i-out, (ret-type, rest))   ] // push-type
                  
  complex-constraint(|r): (instr@RETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Void()) ]
  complex-constraint(|r): (instr@IRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Int()) ]
  complex-constraint(|r): (instr@LRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Long()) ]
  complex-constraint(|r): (instr@FRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Float()) ]
  complex-constraint(|r): (instr@DRETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) // push-type
    	        , CEq(r, Double()) ]
  complex-constraint(|r): (instr@ARETURN(), (c*,r*)) -> ([n*, c*], [r*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; classtype := Reference(CRef(<fresh-var>))
    	; n* := [ CEq(TypeVar(i-out), [])         // push-type
    	        , CEq(TypeVar(i-in), [classtype]) // pop-type
    	        , CSub(classtype, r) ]