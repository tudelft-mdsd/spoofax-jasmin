module analysis/types/solve-constraints

imports
	include/JasminXT
	runtime/nabl/-
	runtime/task/-
  	runtime/types/-
  	trans/analysis/types/-
  	trans/analysis/names/-

strategies
	//the input of this strategy should be a list of constraints!
	solve-constraints = !([], <id>);fixed-point(solve-constraints-step)

    solve-step(|x*) = mapconcat(
    					solve-constraints-lookup(|x*) <+
                      	solve-constraints-unify(|x*) <+
                      	solve-constraints-simple-subtype(|x*) <+
                      	![<id>]
                      )
    
    fixed-point(s) = !(<id>, <s> <id>); if(not(eq), Snd; fixed-point(s), Snd)
    
    is-simple-type = ?Int() <+ ?Double() <+ ?Float() <+ ?Boolean() <+ ?Char() <+ ?Byte() <+ ?Long() <+ ?Short()

rules // general rules
	solve-constraints-step: (x, []) -> (x, [])
	
	solve-constraints-step: (x*, c) -> (xnew*, constr)
		where mapconstr := <solve-step(|x*)> c
			; (xn*, constr) := <partition(solve-constraints-simplify(|x*))> mapconstr
			; xnew* := <uniq; unique-keys> [x*, xn*]
	
	unique-keys: [] -> <id>
	unique-keys: ([x@(key, _) | tail]) ->  [x | <unique-keys> tail]
  		where <not(lookup)> (key, tail)

rules // equality constraints
	solve-constraints-simplify(|x*): CEq(var, type) -> (var, type)
		// warning: should probably check the whole tree for vars
		where TypeVar(_) := var
			; <not(?TypeVar(_))> type
			; t := <lookup <+ !type> (var, x*)
			; <eq> (t, type)
			 
	solve-constraints-unify(|x*): CEq(lt, rt) -> result
		where vars := <unify(?TypeVar(_))> [(lt, rt)]
        	; result := <map(\ (l,r) -> CEq(l,r) \)> vars

	solve-constraints-lookup(|x*): CEq(var, type) -> [CEq(var, t)]
		where TypeVar(_) := type
			; t := <lookup> (type, x*)

rules // subtype constraints
	solve-constraints-simple-subtype(|x*): CSub(var, type) -> [CEq(var, type)]
		where TypeVar(_) := var
			; <is-simple-type> type