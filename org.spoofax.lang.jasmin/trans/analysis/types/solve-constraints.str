module analysis/types/solve-constraints

imports
	include/JasminXT
	runtime/nabl/-
	runtime/task/-
  	runtime/types/-
  	trans/analysis/types/-
  	trans/analysis/names/-

rules
	do_debug(|str): x -> <id>
		where <debug> str

strategies
	//the input of this strategy should be a list of constraints!
	solve-constraints = !([], <id>);fixed-point(solve-constraints-step)

    solve-step(|x*) = solve-constraints-sub-eliminate(|x*);
    				  solve-constraints-rename;
    				  mapconcat(
    					solve-constraints-lookup(|x*) <+
                      	solve-constraints-unify(|x*) <+
                      	solve-constraints-simple-subtype(|x*) <+
                      	![<id>]
                      );
    				  solve-constraints-sub-single(|x*);
    				  uniq
    
    fixed-point(s) = !(<id>, <s> <id>); if(not(eq), Snd; fixed-point(s), Snd)
    
    is-simple-type = ?Int() <+ ?Double() <+ ?Float() <+ ?Boolean() <+ ?Char() <+ ?Byte() <+ ?Long() <+ ?Short()

rules // general rules
	solve-constraints-step: (x, []) -> (x, [])
	
	solve-constraints-step: (x*, c) -> (xnew*, constr)
		where mapconstr := <solve-step(|x*)> c
			; (xn*, constr) := <partition(solve-constraints-simplify(|x*))> mapconstr
			; xnew* := <uniq; unique-keys> [x*, xn*]
	
	unique-keys: [] -> <id>
	unique-keys: ([x@(key, _) | tail]) ->  [x | <unique-keys> tail]
  		where <not(lookup)> (key, tail)

rules // equality constraints
	solve-constraints-simplify(|x*): CEq(var, type) -> (var, type)
		// warning: should probably check the whole tree for vars
		where TypeVar(_) := var
			; <not(?TypeVar(_))> type
			; if t := <lookup> (var, x*)
			    then <eq> (t, type)
			  end
			 
	solve-constraints-unify(|x*): n#([lt, rt]) -> result
		where <?"CEq" <+ ?"CSub"> n
		    ; not(TypeVar(_) := lt)
			; vars := <unify(?TypeVar(_))> [(lt, rt)]
        	; result := <map(\ (l,r) -> <mkterm> (n, [l,r]) \)> vars

	solve-constraints-lookup(|x*): CEq(var, type) -> [CEq(var, t)]
		where TypeVar(_) := type
			; t := <lookup> (type, x*)
	
	rename-equality: (l*, CEq(a@TypeVar(_), b@TypeVar(_)), r*) -> (l*, [r*, na*, nb*])
		where concat := [l*, r*]
			; nb* := <filter(has-subterm(|a)); topdown(try(?a;!b)); filter(not(has-identity))> concat
			; na* := <filter(has-subterm(|b)); topdown(try(?b;!a)); filter(not(has-identity))> concat
	
	has-subterm(|t): x -> x
		where <is-subterm> (t, x)
		
	has-identity: CEq(x, x) -> []
	
	solve-constraints-rename: [] -> []
	solve-constraints-rename: l -> <walk-values(rename-equality)> l

strategies
	walk-values(s) = !([], <id>); walk-value-tuple(s); ?(res, []); !res

	continue-value-tuple = ?(ln*, e, tailn); !([ln*, e], tailn)
 	walk-value-tuple(s) = ?(_, [])
  		< id
  		+ ?(l*, [e | tail]) ; !(l*, e, tail); (s <+ continue-value-tuple) ; walk-value-tuple(s)

rules // subtype constraints
	solve-constraints-simple-subtype(|x*): CSub(var, type) -> [CEq(var, type)]
		where TypeVar(_) := var
			; <is-simple-type <+ ?[]> type
			
	collect-csub-types: [] -> []
	collect-csub-types: [CSub(TypeVar(x), t) | tail] -> [pair | ftail]
		where
			tailpairs := <collect-csub-types> tail
		;	l := <lookup <+ ![]> (x, tailpairs)
		;	pair := (x, [t | l])
		;	ftail := <filter(not(?(x, _)))> tailpairs
	inflate-csub-types: [] -> []
	inflate-csub-types: [(x, l) | tail] -> result
		where
			csub* := <map(\ t -> CSub(TypeVar(x), t) \)> l
		;	tail* := <inflate-csub-types> tail
		;	result := [csub*, tail*]

	// TODO: make the upper bound finder
	find-upper-bound: [x] -> x
	find-upper-bound: [Reference(CRef("java/lang/Object")),Reference(CRef("java/lang/String"))] -> Reference(CRef("java/lang/String"))
	find-upper-bound: [Reference(CRef("java/lang/String")),Reference(CRef("java/lang/Object"))] -> Reference(CRef("java/lang/String"))
			  
	solve-constraints-sub-eliminate(|x*): c* -> cnew*
		where
			(csub*, cold*) := <partition(?CSub(TypeVar(_), _);id)> c*
		;	club* := <collect-csub-types;map(\ (a,b) -> CSub(TypeVar(a), <find-upper-bound> b) \)> csub*
		;	cnew* := [club*, cold*]
		  	
	solve-constraints-sub-single(|x*): c* -> cnew*
		where
			(csub*, cold*) := <partition(?CSub(TypeVar(_), _);id)> c*
		;	csubs := <collect-csub-types> csub*
		;	(csingles, cmore*) := <partition(?(x, [_]);id)> csubs
		;	(ceq*, cevenmore*) := <partition(?(x, [t]); !TypeVar(x); find-references(|cold*); ?[]; !CEq(TypeVar(x), t))> csingles
		;	ckeep* := <inflate-csub-types> [cmore*, cevenmore*]
		;	cnew* := [cold*, ceq*, ckeep*]
		   	
	find-references(|constraints): t@TypeVar(_) -> l
		where
			l := <filter(\ x -> x where <is-subterm> (t, x) \)> constraints
		  	
rules // or constraints
	// TODO

rules // not equals constraints
	// TODO
