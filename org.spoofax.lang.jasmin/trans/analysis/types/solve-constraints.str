module analysis/types/solve-constraints

imports
	include/JasminXT
	runtime/nabl/-
	runtime/task/-
  	runtime/types/-
  	trans/analysis/types/-
  	trans/analysis/names/-

strategies
	//the input of this strategy should be a list of constraints!
	solve-constraints = !([], <id>);fixed-point(solve-constraints-step)

    solve-step(|x*) = solve-constraints-sub-eliminate(|x*);
    				  mapconcat(
    					solve-constraints-lookup(|x*) <+
                      	solve-constraints-unify(|x*) <+
                      	solve-constraints-simple-subtype(|x*) <+
                      	![<id>]
                      )
    
    fixed-point(s) = !(<id>, <s> <id>); if(not(eq), Snd; fixed-point(s), Snd)
    
    is-simple-type = ?Int() <+ ?Double() <+ ?Float() <+ ?Boolean() <+ ?Char() <+ ?Byte() <+ ?Long() <+ ?Short()

rules // general rules
	solve-constraints-step: (x, []) -> (x, [])
	
	solve-constraints-step: (x*, c) -> (xnew*, constr)
		where mapconstr := <solve-step(|x*)> c
			; (xn*, constr) := <partition(solve-constraints-simplify(|x*))> mapconstr
			; xnew* := <uniq; unique-keys> [x*, xn*]
	
	unique-keys: [] -> <id>
	unique-keys: ([x@(key, _) | tail]) ->  [x | <unique-keys> tail]
  		where <not(lookup)> (key, tail)

rules // equality constraints
	solve-constraints-simplify(|x*): CEq(var, type) -> (var, type)
		// warning: should probably check the whole tree for vars
		where TypeVar(_) := var
			; <not(?TypeVar(_))> type
			; t := <lookup <+ !type> (var, x*)
			; <eq> (t, type)
			 
	solve-constraints-unify(|x*): n#([lt, rt]) -> result
		where <?"CEq" <+ ?"CSub"> n
		    ; not(TypeVar(_) := lt)
			; vars := <unify(?TypeVar(_))> [(lt, rt)]
        	; result := <map(\ (l,r) -> <mkterm> (n, [l,r]) \)> vars

	solve-constraints-lookup(|x*): CEq(var, type) -> [CEq(var, t)]
		where TypeVar(_) := type
			; t := <lookup> (type, x*)

rules // subtype constraints
	solve-constraints-simple-subtype(|x*): CSub(var, type) -> [CEq(var, type)]
		where TypeVar(_) := var
			; <is-simple-type <+ ?[]> type
			
	collect-csub-types: [] -> []
	collect-csub-types: [CSub(TypeVar(x), t) | tail] -> [pair | ftail]
		where
			tailpairs := <collect-csub-types> tail
		;	l := <lookup <+ ![]> (x, tailpairs)
		;	<debug> l
		;	<debug> t
		;	pair := (x, [t | l])
		;	<debug> pair
		;	ftail := <filter(not(?(x, _)))> tailpairs
			  
	find-upper-bound: [x] -> x
	find-upper-bound: [Reference(CRef("java/lang/Object")),Reference(CRef("java/lang/String"))] -> Reference(CRef("java/lang/String"))
			  
	solve-constraints-sub-eliminate(|x*): c* -> cnew*
		where
			(csub*, cold*) := <partition(?CSub(TypeVar(_), _);id)> c*
		;	club* := <map(debug;?(a,b);!CSub(TypeVar(a), <find-upper-bound> b))> <debug> <collect-csub-types> csub*
		;	<debug> club*
		;	cnew* := [club*, cold*]
		  	
rules // or constraints
	// TODO

rules // not equals constraints
	// TODO