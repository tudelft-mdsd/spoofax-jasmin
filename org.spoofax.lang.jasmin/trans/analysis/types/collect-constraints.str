module analysis/types/collect-constraints

imports
  include/JasminXT
  analysis/names/properties
  analysis/names/extra-constructors
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  trans/match-Instruction

rules
  fresh-var = !TypeVar(<new>)

  stack-constraints(|ctx): JBCMethod(_, _, _, []) -> []
  stack-constraints(|ctx): JBCMethod(_, _, _, l) -> [stack-start, push*, pop*, next*, complex*]
    where l'@[h|_] := <filter(match-Instruction)> l
    	; h-in  := <get-in-stack>  h
    	; stack-start := CEq(TypeVar(h-in), [])
        ; h-out := <get-out-stack> h
        ; push* := <filter(push-constraints)> l'
        ; pop*  := <filter(pop-constraints)> l'
        ; next* := <foldl(next-constraints(|ctx));Snd> (l', (h-out, []))
        ; complex* := <foldl(complex-constraints);Snd> (l', (h-out, []))
  
  pop-constraints: instr -> CEq(TypeVar(i-in), (p*, <fresh-var>))
    where p* := <pop-type> instr
        ; i-in := <get-in-stack> instr
  pop-type = get-pop-type;not(?[])

  push-constraints: instr -> CEq(TypeVar(i-out), (p*, <fresh-var>))
    where p* := <push-type> instr
        ; i-out := <get-out-stack> instr
  push-type = get-push-type;not(?[])

  next-constraints(|ctx): (instr, (prev-out, c*)) -> (<get-out-stack> instr, [n*, c*])
    where i-in := <get-in-stack> instr
        ; n* := <next-instr;map(next-helper(|ctx, prev-out, i-in))> instr
  
  next-helper(|ctx,prev-out,i-in) = \NEXT() -> CEq(TypeVar(prev-out),TypeVar(i-in))\
                                 <+ \LabelRef(l) -> CEq(TypeVar(prev-out),<get-in-stack> l)\
  next-instr = get-next-instr <+ ![NEXT()]
  
  complex-constraints = complex-constraint <+ \(instr, (prev-out, c*)) -> (<get-out-stack> instr, c*)\
    
  complex-constraint: (instr@ATHROW(), (prev-out, c*)) -> (i-out, [n*, c*])
    where cref  := Reference(CRef(<fresh-var>))
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), ([cref], <fresh-var>)) // pop-type
    	        , CEq(TypeVar(i-out), [cref])         // push-type
    	        ]
  complex-constraint: (instr@CHECKCAST(_), (prev-out, c*)) -> (i-out, [n*, c*])
    where cref  := Reference(CRef(<fresh-var>))
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), ([cref], <fresh-var>)) // pop-type
    	        , CEq(TypeVar(i-out), TypeVar(i-in))         // push-type
    	        ]
  complex-constraint: (instr@DUP(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type@TypeVar(type') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in),  ([type], rest))       // pop-type
    	        , CEq(TypeVar(i-out), ([type, type], rest)) // push-type
    	        , CNEq(TypeVar(type'), Double())
    	        , CNEq(TypeVar(type'), Long())
    	        ]
  complex-constraint: (instr@DUP2(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type@TypeVar(type')  := <fresh-var>
        ; type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type], rest))       // pop-type
    	                , CEq(TypeVar(i-out), ([type, type], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type'), Double()) ]
    	                      , [ CEq(TypeVar(type'), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                ]
    	              ])
    	        ]
  complex-constraint: (instr@DUP_X1(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	        , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	        , CNEq(TypeVar(type1'), Double())
    	        , CNEq(TypeVar(type1'), Long())
    	        , CNEq(TypeVar(type2'), Double())
    	        , CNEq(TypeVar(type2'), Long())
    	        ]
  complex-constraint: (instr@DUP2_X1(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(type2'), Double())
              	, CEq(TypeVar(type2'), Long())
              	, COr([ [ CEq(TypeVar(i-in),  ([type1, type2], rest))       // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type1), Double()) ]
    	                      , [ CEq(TypeVar(type1), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type3'), Double())
              	        , CNEq(TypeVar(type3'), Long())
    	                ]
    	              ])
    	        ]
  complex-constraint: (instr@DUP_X2(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(type1'), Double())
                , CEq(TypeVar(type1'), Long())
                , COr( [ [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))        // pop-type
    	                 , CEq(TypeVar(i-out), ([type1, type2, type3, type1], rest)) // push-type
    	                 , CNEq(TypeVar(type2'), Double())
    	                 , CNEq(TypeVar(type2'), Long())
    	                 , CNEq(TypeVar(type3'), Double())
    	                 , CNEq(TypeVar(type3'), Long())
    	                 ]
    	               , [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	                 , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	                 , COr([ [ CEq(TypeVar(type2'), Double()) ]
    	                       , [ CEq(TypeVar(type2'), Long())   ]
    	                       ])
    	                 ]
    	               ])
	            ]
  complex-constraint: (instr@DUP2_X2(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; type3@TypeVar(type3') := <fresh-var>
        ; type4@TypeVar(type4') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ COr([ [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))        // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type1], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type1'), Double()) ]
    	                      , [ CEq(TypeVar(type1'), Long()) ]
    	                      ])
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                , CNEq(TypeVar(type3'), Double())
              	        , CNEq(TypeVar(type3'), Long())
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2], rest))        // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type1], rest)) // push-type
    	                , COr([ [ CEq(TypeVar(type1'), Double()) ]
    	                      , [ CEq(TypeVar(type1'), Long()) ]
    	                      ])
    	                , COr([ [ CEq(TypeVar(type2'), Double()) ]
    	                      , [ CEq(TypeVar(type2'), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2, type3], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                , COr([ [ CEq(TypeVar(type3'), Double()) ]
    	                      , [ CEq(TypeVar(type3'), Long()) ]
    	                      ])
    	                ]
    	              , [ CEq(TypeVar(i-in),  ([type1, type2, type3, type4], rest))               // pop-type
    	                , CEq(TypeVar(i-out), ([type1, type2, type3, type4, type1, type2], rest)) // push-type
    	                , CNEq(TypeVar(type1'), Double())
              	        , CNEq(TypeVar(type1'), Long())
    	                , CNEq(TypeVar(type2'), Double())
              	        , CNEq(TypeVar(type2'), Long())
    	                , CNEq(TypeVar(type3'), Double())
              	        , CNEq(TypeVar(type3'), Long())
    	                , CNEq(TypeVar(type4'), Double())
              	        , CNEq(TypeVar(type4'), Long())
    	                ]
    	              ])
    	        ]
  complex-constraint: (instr@SWAP(), (prev-out, c*)) -> (i-out, [n*, c*])
    where type1@TypeVar(type1') := <fresh-var>
        ; type2@TypeVar(type2') := <fresh-var>
        ; i-in  := <get-in-stack> instr
        ; i-out := <get-out-stack> instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in),  ([type1, type2], rest)) // pop-type
    	        , CEq(TypeVar(i-out), ([type2, type1], rest)) // push-type
    	        , CNEq(TypeVar(type1'), Double())
    	        , CNEq(TypeVar(type1'), Long())
    	        , CNEq(TypeVar(type2'), Double())
    	        , CNEq(TypeVar(type2'), Long())
    	        ]
  complex-constraint: (instr@RETURN(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) ] // push-type
  complex-constraint: (instr@IRETURN(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) ] // push-type
  complex-constraint: (instr@LRETURN(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) ] // push-type
  complex-constraint: (instr@FRETURN(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) ] // push-type
  complex-constraint: (instr@DRETURN(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-out), []) ] // push-type
  complex-constraint: (instr@ARETURN(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; classtype := Reference(CRef(<fresh-var>))
    	; n* := [ CEq(TypeVar(i-out), [])  // push-type
    	        , CEq(TypeVar(i-in), [classtype]) ] // pop-type
    	        // TODO: add subtype constraint on the classtype to the method return description
    	        
  complex-constraint: (instr@MONITORENTER(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), [Reference(CRef(<fresh-var>))]) ] // pop-type
  complex-constraint: (instr@MONITOREXIT(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-out-stack> instr
    	; n* := [ CEq(TypeVar(i-in), [Reference(CRef(<fresh-var>))]) ] // pop-type
    	  
  complex-constraint: (instr@BALOAD(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
    	; n* := [ COr([ [CEq(TypeVar(i-out), ([Byte()],<fresh-var>))]
    	              , [CEq(TypeVar(i-out), ([Boolean()],<fresh-var>))]]) ] // push-type
  complex-constraint: (instr@BASTORE(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
    	; n* := [ COr([ [CEq(TypeVar(i-in), ([Byte()],<fresh-var>))]
    	              , [CEq(TypeVar(i-in), ([Boolean()],<fresh-var>))]]) ] // pop-type
  complex-constraint: (instr@AALOAD(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef(<fresh-var>))
        ; array-type := Array(<fresh-var>)
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([Int(), Array(class-type)], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([class-type],rest))               ] // push-type
    	             , [ CEq(TypeVar(i-in), ([Int(), Array(array-type)], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([array-type],rest))               ] // push-type
    	             ])]
  complex-constraint: (instr@AASTORE(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef(<fresh-var>))
        ; array-type := Array(<fresh-var>)
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([class-type, Int(), Array(class-type)], rest)) ] // pop-type
    	             , [ CEq(TypeVar(i-in), ([array-type, Int(), Array(array-type)], rest)) ] // pop-type
    	             ])]
  complex-constraint: (instr@BALOAD(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([Int(), Array(Boolean())], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([Boolean()],rest))               ] // push-type
    	             , [ CEq(TypeVar(i-in), ([Int(), Array(Byte())], rest))   // pop-type
    	               , CEq(TypeVar(i-out), ([Byte()],rest))               ] // push-type
    	             ])]
  complex-constraint: (instr@BASTORE(), (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [COr([ [ CEq(TypeVar(i-in), ([Boolean(), Int(), Array(Boolean())], rest)) ] // pop-type
    	             , [ CEq(TypeVar(i-in), ([Byte(), Int(), Array(Byte())], rest)) ] // pop-type
    	             ])]
    	             
  cc-aload-helper(|type): (instr, (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in), ([Int(), Array(type)], rest))   // pop-type
                , CEq(TypeVar(i-out), ([type],rest))               ] // push-type
  cc-astore-helper(|type): (instr, (prev-out, c*)) -> (i-out, [n*, c*])
    where i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
    	; n* := [ CEq(TypeVar(i-in), ([type, Int(), Array(type)], rest)) ] // pop-type
  complex-constraint: (CALOAD(),  (_, _)) -> <cc-aload-helper(|Char())>
  complex-constraint: (CASTORE(), (_, _)) -> <cc-astore-helper(|Char())>
  complex-constraint: (DALOAD(),  (_, _)) -> <cc-aload-helper(|Double())>
  complex-constraint: (DASTORE(), (_, _)) -> <cc-astore-helper(|Double())>
  complex-constraint: (FALOAD(),  (_, _)) -> <cc-aload-helper(|Float())>
  complex-constraint: (FASTORE(), (_, _)) -> <cc-astore-helper(|Float())>
  complex-constraint: (IALOAD(),  (_, _)) -> <cc-aload-helper(|Int())>
  complex-constraint: (IASTORE(), (_, _)) -> <cc-astore-helper(|Int())>
  complex-constraint: (LALOAD(),  (_, _)) -> <cc-aload-helper(|Long())>
  complex-constraint: (LASTORE(), (_, _)) -> <cc-astore-helper(|Long())>
  complex-constraint: (SALOAD(),  (_, _)) -> <cc-aload-helper(|Short())>
  complex-constraint: (SASTORE(), (_, _)) -> <cc-astore-helper(|Short())>
    	  
  complex-constraint: (instr@name#([_]), (prev-out, c*)) -> (i-out, [n*, c*])
    where <string-starts-with(|"ASTORE")> name
    	; i-out := <get-out-stack> instr
        ; i-in  := <get-in-stack>  instr
        ; rest  := <fresh-var>
        ; class-type := Reference(CRef(<fresh-var>))
    	; n* := [ CEq(TypeVar(i-in), ([class-type], rest)) ] // pop-type