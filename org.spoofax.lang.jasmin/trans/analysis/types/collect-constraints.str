module analysis/types/collect-constraints

imports
  include/JasminXT
  analysis/names/properties
  analysis/types/constraints
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  trans/match-Instruction
  analysis/types/complex-constraints/-

rules
  // Deprecated: legacy name
  stack-constraints(|ctx, classname) = collect-constraints(|ctx, classname)
  
  collect-constraints(|ctx, classname): JBCMethod(_, _, JBCMethodDesc(_,r), []) -> [CEq(r, Void())]
  collect-constraints(|ctx, classname): JBCMethod(_, _, JBCMethodDesc(p,r), l) -> [st-start, push*, pop*, next*, st-c*, reg-start, reg-next*, reg-c*]
    where l'@[h|_] := <filter(match-Instruction)> l
    	; h-in  := <get-in-stack>  h
        ; h-out := <get-out-stack> h
        ; next* := <foldl(next-constraints(|ctx));Snd> (l', (h-out, []))
        ; (st-c*,reg-c*) := <foldl(complex-constraints(|r))> (l', ([],[]))
          
    	; st-start := CEq(TypeVar(h-in), [])
        ; push* := <filter(push-constraints)> l'
        ; pop*  := <filter(pop-constraints)> l'
          
        ; locals-start := ([ Reference(CRef(classname)) | p ], <fresh-var>)
        ; reg-start := CEq(<var-rename-hack> TypeVar(h-in), locals-start)
        ; reg-next* := <alltd(var-rename-hack)> next*
        // TODO: handle limits in constraints. 
          // limit locals can be done with a single constraint wherever it is found, setting the locals CSub of [TOP(), ..., TOP()] of the size given in the limit locals phrase
          // limit stack may need intelligent constaints on every in/out stack.. Not sure yet how to solve this
  
  pop-constraints: instr -> CEq(TypeVar(i-in), (p*, <fresh-var>))
    where p* := <pop-type> instr
        ; i-in := <get-in-stack> instr
  pop-type = get-pop-type;not(?[])

  push-constraints: instr -> CEq(TypeVar(i-out), (p*, <fresh-var>))
    where p* := <push-type> instr
        ; i-out := <get-out-stack> instr
  push-type = get-push-type;not(?[])

  next-constraints(|ctx): (instr, (prev-out, c*)) -> (<get-out-stack> instr, [n*, c*])
    where i-in := <get-in-stack> instr
        ; n* := <next-instr;map(next-helper(|ctx, prev-out, i-in))> instr
  
  next-helper(|ctx,prev-out,i-in) = \NEXT() -> CEq(TypeVar(prev-out),TypeVar(i-in))\
                                 <+ \LabelRef(l) -> CEq(TypeVar(prev-out),TypeVar(<get-in-stack> l))\
  next-instr = get-next-instr <+ ![NEXT()]
  
  complex-constraints(|ret) =  \(i,(c,r)) -> (<complex-constraint(|ret)
                                            <+ complex-constraint> (i,c), r)\
                          <+ complex-constraint
                          <+ \(i,rest) -> rest\ // where <debug(!"No complex-constraints for: ")> i\

